package microservices.backend.eir_cdr_repository_backend.utilities;

import java.io.File;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;

import framework.test_data.generic.RandomStringGenerator;
import microservices.backend.eir_cdr_repository_backend.dao.CDRRepoDAO;
import microservices.backend.eir_cdr_repository_backend.data_model.ServiceDetail;
import microservices.backend.eir_cdr_repository_backend.enums.Filter;
import microservices.backend.eir_cdr_repository_backend.enums.ProcessType;
import microservices.backend.eir_cdr_repository_backend.files.UsageFile;
import microservices.backend.eir_cdr_repository_backend.files.UsageRow;
import microservices.backend.eir_subscription_management_backend.SubscriptionManagementDAO;
import microservices.frontend.common_ui.enums.CustomerType;
import utilities.config.ConfigReader;
import utilities.galaxion.ftp.IONFileUploader;
import utilities.generic.files.TextReader;
import utilities.generic.time.TimeUtil;
import utilities.generic.time.Timestamp;
import utilities.generic.time.WaitUtil;

public class CDRGenerator {

	/**
	 * Generate and upload a usage file to CDR repo
	 * 
	 * @param MSISDN        - e.g. 0851231234
	 * @param billCycle     - billing cycle for the usage - e.g. "03-2022"
	 * @param processType   - RANDOM for random usage, or FULL to take all files
	 *                      from the file (in order, up to a max specified)
	 * @param sendToCdrRepo - true to send to the sftp pod
	 * @param limit - number of records required in the file
	 * @param filter - limit the file to a certain usage type - e.g. VOICE, SMS, DATA, MMS
	 * @return a usage file object
	 */
	public static UsageFile generateUsage(String MSISDN, String billCycle, ProcessType processType, boolean sendToCdrRepo, int limit,Filter filter) {

		// get the appropriate template rows for the test
		ArrayList<String> templateRows = getTemplateRows(ProcessType.RANDOM, 5,filter);

		// create a new usage file object
		UsageFile file = new UsageFile();

		Date firstDay = null;
		Date lastDay = null;
		Date dateBillingCycle = null;

		// read the customer details from the database
		CustomerType customerType = SubscriptionManagementDAO.getCustomerType(MSISDN);
		ServiceDetail serviceDetail = CDRRepoDAO.getServiceDetail(MSISDN);

		if (serviceDetail.getEffectiveStartDateTime() == null) {
			System.err.println("Error: CDRGenerator - subProvisionDate is null for " + MSISDN);
			return null;
		}

		System.out.println("Subscriber found: " + serviceDetail.getEffectiveStartDateTime() + ", " + customerType);

		// define the date formats
		SimpleDateFormat sdf = new SimpleDateFormat("MM-yyyy");
		SimpleDateFormat fdf = new SimpleDateFormat("dd-MM-yyyy");
		SimpleDateFormat fullDateFormat = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss");

		try {
			// set the date object based on the billcycle provided
			dateBillingCycle = sdf.parse(billCycle);
			Calendar c = Calendar.getInstance();
			c.setTime(dateBillingCycle);

			// set the start date based on the first day of the billing cycle
			firstDay = fdf.parse("01-" + billCycle);

			// if the period starts before the provisioning date, start on provision date +
			// 1
			if (firstDay.before(serviceDetail.getEffectiveStartDateTime())) {
				firstDay = new Date(serviceDetail.getEffectiveStartDateTime().getTime() + 86400000);
			}

			// calculate last day based the number of days in the specified month
			int daysInMonth = c.getActualMaximum(Calendar.DATE);
			lastDay = fdf.parse(daysInMonth + "-" + billCycle);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		// get random timestamps in the specified billing period
		ArrayList<Date> dates = TimeUtil.getRandomDates(limit, firstDay,lastDay);

		// This will reference one line at a time
		String cdrContents = "";
		String line = null;

		// for each usage record requested...
		for (String templateRow : templateRows) {

			// get the next random charge start date from the list
			String dateString = fullDateFormat.format(dates.get(0));
			dates.remove(0);
			
			// generate the usage record string
			line = templateRow.replace("$msisdn", MSISDN).replace("$timestamp", dateString).replace("$epoch",
					"auto" + String.valueOf(System.currentTimeMillis()));

			// add the usage record to the file string
			cdrContents = cdrContents + line + "\n";

			// add the record object to the file object
			file.getUsageRecords().add(new UsageRow(line));

			// wait 1 millisecond
			WaitUtil.waitForMilliSeconds(1);
		}

		// trim the last newline character off the contents string
		cdrContents = cdrContents.trim();

		// generate a unique filename for the CDR file
		String filename = "autoGeneratedCdrEvents_" + customerType.toString().toLowerCase() + "_" + Timestamp.getCurrentTimestamp("yyyyMMddHHmmss") + ".evt";
		file.setFilename(filename);

		// Write the file
		String eventPath = System.getProperty("user.dir") + "\\files\\usage\\" + filename;

		File cdrFile = new File(eventPath);
		System.out.println("Generating file " + cdrFile.getName());

		// write the CDR contents to a file
		TextReader.writeFile(cdrContents, cdrFile.getPath());

		// Send to CDR repo
		if (sendToCdrRepo) {
			uploadUsageFile(customerType, eventPath);
		}

		return file;
	}

	/**
	 * Upload the usage file to the required directory
	 * 
	 * @param customerType
	 * @param localFilepath
	 */
	private static void uploadUsageFile(CustomerType customerType, String localFilepath) {

		String directory = null;

		// determine the destination directory based on the customer type
		if (customerType == CustomerType.GOMO) {
			directory = ConfigReader.getConfigValue("ion_gomo_usage_directory");
		} else if (customerType == CustomerType.EIR_PREPAY) {
			directory = ConfigReader.getConfigValue("ion_prepay_usage_directory");
		} else if (customerType == CustomerType.EIR_B2B) {
			directory = ConfigReader.getConfigValue("ion_b2b_usage_directory");
		} else if (customerType == CustomerType.EIR_POSTPAY) {
			directory = ConfigReader.getConfigValue("ion_eir_postpay_usage_directory");
		}

		// send the file to the relevant directory within the pod
		IONFileUploader.uploadFile(localFilepath, "eir-sftp-backend", directory);
	}

	/**
	 * Return a list of rows from the CDR template file
	 * 
	 * @param processType
	 * @param limit
	 * @return a list of template rows from the template file
	 */
	private static ArrayList<String> getTemplateRows(ProcessType processType, int limit, Filter filter) {

		// read everything from the template file
		ArrayList<String> templateRows = TextReader.getContentAsArrayList(ConfigReader.getConfigValue("cdr_template"));

		if (filter != null) {
			ArrayList<String> filteredTemplateRows = new ArrayList<String>();
			
			// determine the expected full path value for the filter specified
			String expectedFullPathValue="";
			if(filter==Filter.DATA) {
				expectedFullPathValue="1300";
			}
			else if(filter==Filter.SMS) {
				expectedFullPathValue="1100";
			}
			else if(filter==Filter.VOICE) {
				expectedFullPathValue="1000";
			}
			else if(filter==Filter.MMS) {
				expectedFullPathValue="1200";
			}
			
			// for each row in the template that matches the fullpath value, add is to the list
			for (String templateRow : templateRows) {
				String fullPath = templateRow.split("\\|")[42];
				if(fullPath.equals(expectedFullPathValue)) {
					filteredTemplateRows.add(templateRow);
				}
			}
			
			// set the template row list to be the filtered list
			templateRows=filteredTemplateRows;
		}

		ArrayList<String> rows = new ArrayList<String>();

		// if type is random, shuffle the list
		if (processType == ProcessType.RANDOM) {
			Collections.shuffle(templateRows);
		}

		// return the requested list of template rows
		for (int i = 0; i < limit; i++) {
			rows.add(templateRows.get(i));
		}

		return rows;
	}
}
